/***************************************************************
pVolumeRender.hlsl: Renders a 3D texture using ray-marching

Author: Valentin Hinov
Date: 23/02/2014
***************************************************************/

// Constant buffers
cbuffer BufferPerFrame : register (b0) {
	float3 vEyePos;	
	float  padding1;	// 16 bytes
};

cbuffer BufferPerObject : register (b1) {
	float3 vTranslate;  
	float  padding2;	// 16 bytes

	float3 vScale;
	float  padding3;	// 32 bytes
};

cbuffer SmokePropertiesBuffer : register (b2) {
	float4 vSmokeColor;

	float fSmokeAbsorption;
	int iNumSamples;
	float2 padding;		// 32 bytes
};

Texture3D<float> volumeValues : register (t0);

// TODO - replace with point sampler?
SamplerState linearSampler : register (s0);

struct PixelInputType {
	float4 position : SV_POSITION;
	float3 worldPosition : TEXCOORD0;
};

struct Ray {
	float3 origin;
	float3 dir;
};
			
struct AABB {
	float3 Min;
	float3 Max;
};

// find intersection points of a ray with a box
bool IntersectBox(Ray r, AABB aabb, out float t0, out float t1) {
	float3 invR = 1.0f / r.dir;
	float3 tbot = invR * (aabb.Min-r.origin);
	float3 ttop = invR * (aabb.Max-r.origin);
	float3 tmin = min(ttop, tbot);
	float3 tmax = max(ttop, tbot);
	float2 t = max(tmin.xx, tmin.yz);
	t0 = max(t.x, t.y);
	t = min(tmax.xx, tmax.yz);
	t1 = min(t.x, t.y);
	return t0 <= t1;
}

float SampleDensity(float3 uv) {
	return volumeValues.SampleLevel(linearSampler, uv, 0);
}

float SampleBilinear(float3 uv) {
	// Get the dimensions of the volume domain
	uint3 vDimensions;
	volumeValues.GetDimensions(vDimensions.x, vDimensions.y, vDimensions.z);

	uv = saturate(uv);
	uv = uv * (vDimensions - 1.0f);
	
	int x = uv.x;
	int y = uv.y;
	int z = uv.z;
	
	float fx = uv.x-x;
	float fy = uv.y-y;
	float fz = uv.z-z;
	
	int xp1 = min(vDimensions.x-1, x+1);
	int yp1 = min(vDimensions.y-1, y+1);
	int zp1 = min(vDimensions.z-1, z+1);

	float x0 = volumeValues[uint3(x,y,z)] * (1.0f - fx) + volumeValues[uint3(xp1,y,z)] * fx;
	float x1 = volumeValues[uint3(x,y,zp1)] * (1.0f - fx) + volumeValues[uint3(xp1,y,zp1)] * fx;

	float x2 = volumeValues[uint3(x,yp1,z)] * (1.0f  -fx) + volumeValues[uint3(xp1,yp1,z)] * fx;
	float x3 = volumeValues[uint3(x,yp1,zp1)] * (1.0f - fx) + volumeValues[uint3(xp1,yp1,zp1)] * fx;

	float z0 = x0 * (1.0f - fz) + x1 * fz;
	float z1 = x2 * (1.0f - fz) + x3 * fz;

	return z0 * (1.0f - fy) + z1 * fy;
}

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 VolumeRenderPixelShader(PixelInputType input) : SV_TARGET {
	float3 pos = vEyePos;

	Ray r;
	r.origin = pos;
	r.dir = normalize(input.worldPosition - pos);

	AABB aabb;
	aabb.Min = float3(-0.5f, -0.5f, -0.5f) * vScale + vTranslate;
	aabb.Max = float3(0.5f, 0.5f, 0.5f) * vScale + vTranslate;

	//figure out where ray from eye hit front of cube
	float tnear, tfar;
	IntersectBox(r, aabb, tnear, tfar);

	//if eye is in cube then start ray at eye
	if (tnear < 0.0f) {
		tnear = 0.0f;
	}

	float3 rayStart = r.origin + r.dir * tnear;
	float3 rayStop = r.origin + r.dir * tfar;

	//convert to texture space
	rayStart -= vTranslate;
	rayStop -= vTranslate;
	float3 halfScale = 0.5f * vScale;
	rayStart = (rayStart + halfScale) / vScale;
	rayStop = (rayStop + halfScale) / vScale;

	float3 start = rayStart;
	float dist = distance(rayStop, rayStart);
	float stepSize = dist / float(iNumSamples);
	float3 ds = normalize(rayStop - rayStart) * stepSize;
	float alpha = 1.0f;

	for(int i = 0; i < iNumSamples; i++, start += ds) {	 
		float D = SampleDensity(start);	
		alpha *= 1.0f - saturate(D * stepSize * fSmokeAbsorption);		

		if (alpha <= 0.01f) {
			break;
		}
	}
	
	return vSmokeColor * (1.0f - alpha);
}