/***************************************************************
pVolumeRender.hlsl: Renders a 3D texture using ray-marching

Author: Valentin Hinov
Date: 23/02/2014
***************************************************************/

// Constant buffers
cbuffer InputBuffer : register (b0) {
	float3 vDimensions;			
	float  padding0;	// 16 bytes

	float3 vEyePos;	
	float  padding1;	// 32 bytes		

	float3 vTranslate;  
	float  padding2;	// 48 bytes

	float3 vScale;
	float  padding3;	// 64 bytes
};

cbuffer SmokePropertiesBuffer : register (b1) {
	float4 vSmokeColor;
	float fSmokeAbsorption;
	int iNumSamples;

	float2 padding;
};

Texture3D<float> volumeValues : register (t0);

// TODO - replace with point sampler?
SamplerState linearSampler : register (s0);

struct PixelInputType {
	float4 position : SV_POSITION;
	float3 worldPosition : TEXCOORD0;
};

struct Ray {
	float3 origin;
	float3 dir;
};
			
struct AABB {
	float3 Min;
	float3 Max;
};

// find intersection points of a ray with a box
bool IntersectBox(Ray r, AABB aabb, out float t0, out float t1) {
	float3 invR = 1.0f / r.dir;
	float3 tbot = invR * (aabb.Min-r.origin);
	float3 ttop = invR * (aabb.Max-r.origin);
	float3 tmin = min(ttop, tbot);
	float3 tmax = max(ttop, tbot);
	float2 t = max(tmin.xx, tmin.yz);
	t0 = max(t.x, t.y);
	t = min(tmax.xx, tmax.yz);
	t1 = min(t.x, t.y);
	return t0 <= t1;
}

float SampleDensity(float3 uv) {
	return volumeValues.SampleLevel(linearSampler, uv, 0);
}

// TODO - Add bilinear sampling
float SampleBilinear(float3 uv) {
	//uv = saturate(uv);
	//uv = uv * (vDimensions - 1.0f);

	int x = uv.x;
	int y = uv.y;
	int z = uv.z;
	
	//int X = vDimensions.x;
	//int XY = vDimensions.x * vDimensions.y;
	
	float fx = uv.x - x;
	float fy = uv.y - y;
	float fz = uv.z - z;
	
	int xp1 = min(vDimensions.x - 1, x + 1);
	int yp1 = min(vDimensions.y - 1, y + 1);
	int zp1 = min(vDimensions.z - 1, z + 1);

	float x0 = ( SampleDensity(uv) * (1.0f - fx) ) + ( SampleDensity(uv + float3(xp1,0,0)) * fx );
	float x1 = ( SampleDensity(uv + float3(0,0,zp1)) * (1.0f-fx) ) + ( SampleDensity(uv + float3(xp1,0,zp1)) * fx );
	
	float x2 = ( SampleDensity(uv + float3(0,yp1,0)) * (1.0f-fx) ) + ( SampleDensity(uv + float3(xp1,yp1,0)) * fx );
	float x3 = ( SampleDensity(uv + float3(0,yp1,zp1)) * (1.0f-fx) ) + ( SampleDensity(uv + float3(xp1,yp1,zp1)) * fx );

	float z0 = x0 * (1.0f-fz) + x1 * fz;
	float z1 = x2 * (1.0f-fz) + x3 * fz;

	return z0 * (1.0f-fy) + z1 * fy;

	//float x0 = buffer[x+y*X+z*XY] * (1.0f-fx) + buffer[xp1+y*X+z*XY] * fx;
	//float x1 = buffer[x+y*X+zp1*XY] * (1.0f-fx) + buffer[xp1+y*X+zp1*XY] * fx;
	//
	//float x2 = buffer[x+yp1*X+z*XY] * (1.0f-fx) + buffer[xp1+yp1*X+z*XY] * fx;
	//float x3 = buffer[x+yp1*X+zp1*XY] * (1.0f-fx) + buffer[xp1+yp1*X+zp1*XY] * fx;
	//
	//float z0 = x0 * (1.0f-fz) + x1 * fz;
	//float z1 = x2 * (1.0f-fz) + x3 * fz;
	//
	//return z0 * (1.0f-fy) + z1 * fy;
}

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 VolumeRenderPixelShader(PixelInputType input) : SV_TARGET {
	float3 pos = vEyePos;

	Ray r;
	r.origin = pos;
	r.dir = normalize(input.worldPosition - pos);

	AABB aabb;
	aabb.Min = float3(-0.5f, -0.5f, -0.5f) * vScale + vTranslate;
	aabb.Max = float3(0.5f, 0.5f, 0.5f) * vScale + vTranslate;

	//figure out where ray from eye hit front of cube
	float tnear, tfar;
	IntersectBox(r, aabb, tnear, tfar);

	//if eye is in cube then start ray at eye
	if (tnear < 0.0f) {
		tnear = 0.0f;
	}

	float3 rayStart = r.origin + r.dir * tnear;
	float3 rayStop = r.origin + r.dir * tfar;

	//convert to texture space
	rayStart -= vTranslate;
	rayStop -= vTranslate;
	rayStart = (rayStart + 0.5f * vScale) / vScale;
	rayStop = (rayStop + 0.5f * vScale) / vScale;

	float3 start = rayStart;
	float dist = distance(rayStop, rayStart);
	float stepSize = dist / float(iNumSamples);
	float3 ds = normalize(rayStop - rayStart) * stepSize;
	float alpha = 1.0f;

	for(int i = 0; i < iNumSamples; i++, start += ds) {	 
		float D = SampleDensity(start);	
		//float D = volumeValues.SampleLevel(linearSampler, start, 0);	
		alpha *= 1.0f - saturate(D * stepSize * fSmokeAbsorption);		

		if (alpha <= 0.01f) {
			break;
		}
	}
	
	return vSmokeColor * (1.0f - alpha);
}